-- C·∫•u h√¨nh h·ªá th·ªëng
local WEBHOOK_URL = "https://discord.com/api/webhooks/972059328276201492/DPHtxfsIldI5lND2dYUbA8WIZwp4NLYsPDG1Sy6-MKV9YMgV8OohcTf-00SdLmyMpMFC"
local XP_LIMIT = 10000
local SAVE_FILE = "BattlePassProgress.txt"

-- Mapping gi·ªØa t√™n hi·ªÉn th·ªã v√† remote
local BATTLE_PASSES = {
    ["HALLOWEEN 2024"] = {remote = "HW24", display = "HALLOWEEN 2024"},
    ["TOWER BATTLES"] = {remote = "TB", display = "TOWER BATTLES"},
    ["CHRISTMAS 2024"] = {remote = "XMAS24", display = "CHRISTMAS 2024"}
}

-- Kh·ªüi t·∫°o d·ªãch v·ª•
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")

-- Bi·∫øn l∆∞u tr·ªØ
local progress = {}
local currentBP = nil
local initialXP = 0
local lastXP = 0
local lastLevel = 0

-- ========== H·ªÜ TH·ªêNG L∆ØU FILE ========== --
local function saveProgress()
    local data = {}
    for displayName, bpData in pairs(BATTLE_PASSES) do
        data[bpData.remote] = progress[bpData.remote] or 0
    end
    writefile(SAVE_FILE, HttpService:JSONEncode(data))
end

local function loadProgress()
    if isfile(SAVE_FILE) then
        local success, data = pcall(function()
            return HttpService:JSONDecode(readfile(SAVE_FILE))
        end)
        if success then
            for displayName, bpData in pairs(BATTLE_PASSES) do
                progress[bpData.remote] = data[bpData.remote] or 0
            end
            return
        end
    end
    
    -- Kh·ªüi t·∫°o m·ªõi n·∫øu kh√¥ng c√≥ file
    for displayName, bpData in pairs(BATTLE_PASSES) do
        progress[bpData.remote] = 0
    end
end

-- ========== H·ªÜ TH·ªêNG DISCORD ========== --
local function sendToDiscord(message)
    local data = {
        ["content"] = message,
        ["username"] = "BP Tracker",
        ["avatar_url"] = "https://i.imgur.com/Lyq5mJO.png"
    }
    
    pcall(function()
        HttpService:PostAsync(WEBHOOK_URL, HttpService:JSONEncode(data))
    end)
end

-- ========== H·ªÜ TH·ªêNG THEO D√ïI XP ========== --
local function getCurrentXP()
    local success, xpText = pcall(function()
        return LocalPlayer.PlayerGui.GUI.BattlePass.BattlePassDetails.LevelInfo.XP.TextLabel.Text
    end)
    local currentXP = (success and tonumber(xpText:match("%d+"))) or 0
    
    local success, levelText = pcall(function()
        return LocalPlayer.PlayerGui.Model.GUI.BattlePass.BattlePassDetails.LevelInfo.Current.TextLabel.Text
    end)
    local currentLevel = (success and tonumber(levelText:match("%d+"))) or 0
    
    return currentXP, currentLevel
end

local function getCurrentBattlePass()
    local success, displayName = pcall(function()
        return LocalPlayer.PlayerGui.GUI.BattlePass.BattlePassDetails.PreviewInfo.DisplayName.Text
    end)
    return success and displayName or nil
end

-- ========== H·ªÜ TH·ªêNG ƒê·ªîI BATTLEPASS ========== --
local function activateBattlePass(battlePassName)
    -- Ki·ªÉm tra t√™n h·ª£p l·ªá
    local isValid = false
    for _, bpData in pairs(BATTLE_PASSES) do
        if bpData.remote == battlePassName then
            isValid = true
            break
        end
    end
    
    if not isValid then
        warn("T√™n BattlePass kh√¥ng h·ª£p l·ªá:", battlePassName)
        return false
    end
    
    -- G·ªçi remote function
    local network = ReplicatedStorage:WaitForChild("Network", 5)
    if not network then
        warn("Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c Network")
        return false
    end
    
    local remote = network:WaitForChild("BattlePassRequestActivate", 5)
    if not remote then
        warn("Kh√¥ng t√¨m th·∫•y RemoteFunction")
        return false
    end
    
    local success, result = pcall(function()
        return remote:InvokeServer(battlePassName)
    end)
    
    if not success then
        warn("L·ªói khi k√≠ch ho·∫°t BattlePass:", result)
        return false
    end
    
    return true
end

-- ========== H·ªÜ TH·ªêNG T·ª∞ ƒê·ªòNG ========== --
local function getNextBattlePass()
    for displayName, bpData in pairs(BATTLE_PASSES) do
        if progress[bpData.remote] < XP_LIMIT then
            return bpData.remote, displayName
        end
    end
    return nil, nil
end

local function allMaxed()
    for _, bpData in pairs(BATTLE_PASSES) do
        if progress[bpData.remote] < XP_LIMIT then
            return false
        end
    end
    return true
end

local function checkProgress()
    local currentXP, currentLevel = getCurrentXP()
    local displayName = getCurrentBattlePass()
    
    if not displayName or not BATTLE_PASSES[displayName] then
        warn("Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c BattlePass hi·ªán t·∫°i")
        return
    end
    
    local bpData = BATTLE_PASSES[displayName]
    
    -- L·∫ßn ƒë·∫ßu kh·ªüi ƒë·ªông
    if initialXP == 0 then
        initialXP = currentXP
        lastXP = currentXP
        lastLevel = currentLevel
        return
    end
    
    -- Ki·ªÉm tra XP thay ƒë·ªïi
    if currentXP ~= lastXP then
        local xpGained = currentXP - lastXP
        if xpGained > 0 then
            progress[bpData.remote] = math.min(progress[bpData.remote] + xpGained, XP_LIMIT)
            saveProgress()
            
            -- G·ª≠i th√¥ng b√°o Discord
            local message = string.format(
                "üéØ %s: +%d XP (T·ªïng: %d/%d)\nLevel: %d",
                displayName, xpGained, progress[bpData.remote], XP_LIMIT, currentLevel
            )
            sendToDiscord(message)
            
            -- Ki·ªÉm tra n·∫øu ƒë·∫°t gi·ªõi h·∫°n
            if progress[bpData.remote] >= XP_LIMIT then
                sendToDiscord(string.format("‚úÖ ƒê√£ ƒë·∫°t ƒë·ªß %d XP cho %s!", XP_LIMIT, displayName))
                
                -- Chuy·ªÉn sang BattlePass ti·∫øp theo
                local nextBP, nextDisplay = getNextBattlePass()
                if nextBP then
                    if activateBattlePass(nextBP) then
                        sendToDiscord("üîÑ ƒê√£ chuy·ªÉn sang: "..nextDisplay)
                        -- Reset gi√° tr·ªã theo d√µi
                        initialXP, lastXP = getCurrentXP()
                        lastLevel = currentLevel
                    end
                else
                    sendToDiscord("üèÜ ƒê√É HO√ÄN TH√ÄNH T·∫§T C·∫¢ BATTLEPASS!")
                    LocalPlayer:Kick("Ho√†n th√†nh t·∫•t c·∫£ BattlePass!")
                end
            end
        end
        
        lastXP = currentXP
        lastLevel = currentLevel
    end
end

-- ========== KH·ªûI CH·∫†Y CH∆Ø∆†NG TR√åNH ========== --
local function main()
    loadProgress()
    
    -- K√≠ch ho·∫°t BattlePass ƒë·∫ßu ti√™n
    local nextBP, nextDisplay = getNextBattlePass()
    if nextBP then
        if activateBattlePass(nextBP) then
            initialXP, lastXP = getCurrentXP()
            lastLevel = getCurrentXP()
            
            -- G·ª≠i th√¥ng b√°o kh·ªüi ƒë·ªông
            local startMsg = "üöÄ B·∫ÆT ƒê·∫¶U THEO D√ïI BATTLEPASS\n"
            for displayName, bpData in pairs(BATTLE_PASSES) do
                startMsg = startMsg .. string.format("%s: %d/%d\n", displayName, progress[bpData.remote], XP_LIMIT)
            end
            startMsg = startMsg .. string.format("\nüîõ ƒêANG K√çCH HO·∫†T: %s", nextDisplay)
            sendToDiscord(startMsg)
        else
            warn("Kh√¥ng th·ªÉ k√≠ch ho·∫°t BattlePass ban ƒë·∫ßu")
            return
        end
    else
        sendToDiscord("üéñÔ∏è T·∫§T C·∫¢ BATTLEPASS ƒê√É HO√ÄN TH√ÄNH!")
        return
    end
    
    -- B·∫Øt ƒë·∫ßu v√≤ng l·∫∑p ki·ªÉm tra
    while wait(5) do
        if allMaxed() then break end
        checkProgress()
    end
end

-- Ch·∫°y ch∆∞∆°ng tr√¨nh v·ªõi x·ª≠ l√Ω l·ªói
local success, err = pcall(main)
if not success then
    warn("L·ªói ch√≠nh:", err)
    sendToDiscord("‚ùå L·ªñI NGHI√äM TR·ªåNG: "..tostring(err))
end
