-- C·∫•u h√¨nh
local WEBHOOK_URL = "https://discord.com/api/webhooks/972059328276201492/DPHtxfsIldI5lND2dYUbA8WIZwp4NLYsPDG1Sy6-MKV9YMgV8OohcTf-00SdLmyMpMFC"
local XP_LIMIT = 10000
local SAVE_FILE = "BattlePassProgress.txt"

-- Danh s√°ch BattlePass
local BATTLE_PASSES = {
    {remote = "TB", display = "TOWER BATTLES"},
    {remote = "HW24", display = "HALLOWEEN 2024"}, 
    {remote = "XMAS24", display = "CHRISTMAS 2024"}
}

-- D·ªãch v·ª• Roblox
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")

-- H√†m g·ª≠i Discord (qua executor)
local function sendToDiscord(message)
    local data = {
        content = message,
        username = "BP Tracker",
        avatar_url = "https://i.imgur.com/Lyq5mJO.png"
    }

    local encoded = HttpService:JSONEncode(data)

    local req = syn and syn.request or http and http.request or request or http_request

    if req then
        local success, res = pcall(function()
            return req({
                Url = WEBHOOK_URL,
                Method = "POST",
                Headers = {
                    ["Content-Type"] = "application/json"
                },
                Body = encoded
            })
        end)

        if not success or (res and res.StatusCode >= 400) then
            warn("‚ùå L·ªói g·ª≠i Discord:", res and res.StatusCode)
            return false
        end

        return true
    else
        warn("‚ùå Executor kh√¥ng h·ªó tr·ª£ HTTP request")
        return false
    end
end

-- ========== L∆∞u v√† t·∫£i ti·∫øn tr√¨nh ========== --
local progress = {}
local isFirstCheck = true
local lastXP, lastLevel = 0, 0

local function saveProgress()
    local data = {}
    for _, bp in ipairs(BATTLE_PASSES) do
        data[bp.remote] = progress[bp.remote] or 0
    end
    writefile(SAVE_FILE, HttpService:JSONEncode(data))
end

local function loadProgress()
    if isfile(SAVE_FILE) then
        local ok, data = pcall(function()
            return HttpService:JSONDecode(readfile(SAVE_FILE))
        end)
        if ok then
            for _, bp in ipairs(BATTLE_PASSES) do
                progress[bp.remote] = data[bp.remote] or 0
            end
            return
        end
    end
    for _, bp in ipairs(BATTLE_PASSES) do
        progress[bp.remote] = 0
    end
end

-- ========== BattlePass logic ========== --
local function getCurrentXP()
    local ok, xpText = pcall(function()
        return LocalPlayer.PlayerGui.GUI.BattlePass.BattlePassDetails.LevelInfo.XP.TextLabel.Text
    end)
    return (ok and tonumber(xpText:match("%d+"))) or 0
end

local function getCurrentLevel()
    local ok, lvlText = pcall(function()
        return LocalPlayer.PlayerGui.Model.GUI.BattlePass.BattlePassDetails.LevelInfo.Current.TextLabel.Text
    end)
    return (ok and tonumber(lvlText:match("%d+"))) or 0
end

local function getCurrentBattlePass()
    local ok, name = pcall(function()
        return LocalPlayer.PlayerGui.GUI.BattlePass.BattlePassDetails.PreviewInfo.DisplayName.Text
    end)
    if ok then
        for _, bp in ipairs(BATTLE_PASSES) do
            if bp.display == name then
                return bp.remote, bp.display
            end
        end
    end
    return nil, nil
end

local function activateBattlePass(bpName)
    local remote = ReplicatedStorage:FindFirstChild("Network") and ReplicatedStorage.Network:FindFirstChild("BattlePassRequestActivate")
    if not remote then return false end
    local ok, result = pcall(function()
        return remote:InvokeServer(bpName)
    end)
    return ok and result or false
end

local function getNextBattlePass()
    for _, bp in ipairs(BATTLE_PASSES) do
        if progress[bp.remote] < XP_LIMIT then
            return bp.remote, bp.display
        end
    end
    return nil, nil
end

local function allMaxed()
    for _, bp in ipairs(BATTLE_PASSES) do
        if progress[bp.remote] < XP_LIMIT then
            return false
        end
    end
    return true
end

-- ========== Ki·ªÉm tra v√† theo d√µi ti·∫øn tr√¨nh ========== --
local function checkProgress()
    local curXP = getCurrentXP()
    local curLevel = getCurrentLevel()
    local bpRemote, bpDisplay = getCurrentBattlePass()

    if not bpRemote then return end

    if isFirstCheck then
        lastXP = curXP
        lastLevel = curLevel
        isFirstCheck = false
        return
    end

    if curXP ~= lastXP then
        local gain = curXP - lastXP
        if gain > 0 then
            progress[bpRemote] = math.min(progress[bpRemote] + gain, XP_LIMIT)
            saveProgress()

            sendToDiscord(string.format(
                "üéØ %s: +%d XP (T·ªïng: %d/%d)\nLevel: %d",
                bpDisplay, gain, progress[bpRemote], XP_LIMIT, curLevel
            ))

            if progress[bpRemote] >= XP_LIMIT then
                sendToDiscord(string.format("‚úÖ ƒê√£ ho√†n th√†nh %s!", bpDisplay))
                local next, nextDisplay = getNextBattlePass()
                if next then
                    if activateBattlePass(next) then
                        sendToDiscord("üîÑ Chuy·ªÉn sang: " .. nextDisplay)
                        isFirstCheck = true
                    end
                else
                    sendToDiscord("üèÅ ƒê√É HO√ÄN TH√ÄNH T·∫§T C·∫¢ BATTLEPASS!")
                    LocalPlayer:Kick("Ho√†n th√†nh t·∫•t c·∫£ BattlePass!")
                end
            end
        end
        lastXP = curXP
        lastLevel = curLevel
    end
end

-- ========== Main ========== --
local function main()
    sendToDiscord("üü¢ B·∫Øt ƒë·∫ßu theo d√µi BattlePass")
    loadProgress()

    local bp, display = getNextBattlePass()
    if bp and activateBattlePass(bp) then
        local msg = "üöÄ B·∫ÆT ƒê·∫¶U:\n"
        for _, b in ipairs(BATTLE_PASSES) do
            msg = msg .. string.format("%s: %d/%d\n", b.display, progress[b.remote], XP_LIMIT)
        end
        msg = msg .. "üîõ ƒêANG K√çCH HO·∫†T: " .. display
        sendToDiscord(msg)
        isFirstCheck = true
    else
        sendToDiscord("üéñÔ∏è T·∫§T C·∫¢ BATTLEPASS ƒê√É HO√ÄN TH√ÄNH!")
        return
    end

    while task.wait(5) do
        if allMaxed() then break end
        checkProgress()
    end
end

-- B·∫Øt ƒë·∫ßu
local ok, err = pcall(main)
if not ok then
    warn("‚ùå L·ªói:", err)
    sendToDiscord("üí• L·ªói nghi√™m tr·ªçng: " .. tostring(err))
end
