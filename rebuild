-- Formation Manager Script - T·ª± ƒë·ªông l∆∞u v√† rebuild ƒë·ªôi h√¨nh
local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local cashStat = player:WaitForChild("leaderstats"):WaitForChild("Cash")
local Remotes = ReplicatedStorage:WaitForChild("Remotes")

-- File paths
local formationFile = "tdx/formation.json"
local tempFile = "tdx/temp_formation.json"

-- T·∫°o th∆∞ m·ª•c n·∫øu ch∆∞a c√≥
if makefolder then
    pcall(function() makefolder("tdx") end)
end

-- Safe Require
local function SafeRequire(path, timeout)
    timeout = timeout or 5
    local t0 = os.clock()
    while os.clock() - t0 < timeout do
        local success, result = pcall(function()
            return require(path)
        end)
        if success then return result end
        task.wait()
    end
    return nil
end

-- Load TowerClass
local function LoadTowerClass()
    local ps = player:WaitForChild("PlayerScripts")
    local client = ps:WaitForChild("Client")
    local gameClass = client:WaitForChild("GameClass")
    local towerModule = gameClass:WaitForChild("TowerClass")
    return SafeRequire(towerModule)
end

local TowerClass = LoadTowerClass()
if not TowerClass then error("Kh√¥ng th·ªÉ t·∫£i TowerClass") end

-- L·∫•y th√¥ng tin tower t·ª´ GUI
local function GetTowerPlaceCostByName(name)
    local playerGui = player:FindFirstChild("PlayerGui")
    if not playerGui then return 0 end
    local interface = playerGui:FindFirstChild("Interface")
    if not interface then return 0 end
    local bottomBar = interface:FindFirstChild("BottomBar")
    if not bottomBar then return 0 end
    local towersBar = bottomBar:FindFirstChild("TowersBar")
    if not towersBar then return 0 end
    
    for _, tower in ipairs(towersBar:GetChildren()) do
        if tower.Name == name then
            local costFrame = tower:FindFirstChild("CostFrame")
            local costText = costFrame and costFrame:FindFirstChild("CostText")
            if costText then
                local raw = tostring(costText.Text):gsub("%D", "")
                return tonumber(raw) or 0
            end
        end
    end
    return 0
end

-- L·∫•y th√¥ng tin ƒë·∫ßy ƒë·ªß c·ªßa tower
local function GetTowerInfo(hash, tower)
    local success, result = pcall(function()
        local model = tower.Character:GetCharacterModel()
        local root = model and (model.PrimaryPart or model:FindFirstChild("HumanoidRootPart"))
        if not root then return nil end
        
        local pos = root.Position
        local hp = tower.HealthHandler and tower.HealthHandler:GetHealth() or 0
        if hp <= 0 then return nil end
        
        -- L·∫•y th√¥ng tin level
        local levels = {}
        if tower.LevelHandler then
            for path = 1, 3 do
                levels[path] = tower.LevelHandler:GetLevelOnPath(path) or 0
            end
        end
        
        -- L·∫•y target type
        local targetType = 1
        if tower.TargetHandler then
            targetType = tower.TargetHandler:GetQueryType() or 1
        end
        
        return {
            hash = hash,
            name = tower.Name,
            position = {x = pos.X, y = pos.Y, z = pos.Z},
            levels = levels,
            targetType = targetType,
            placeCost = GetTowerPlaceCostByName(tower.Name)
        }
    end)
    
    return success and result or nil
end

-- L∆∞u ƒë·ªôi h√¨nh hi·ªán t·∫°i
local function SaveCurrentFormation()
    local formation = {}
    
    for hash, tower in pairs(TowerClass.GetTowers()) do
        local info = GetTowerInfo(hash, tower)
        if info then
            table.insert(formation, info)
        end
    end
    
    -- S·∫Øp x·∫øp theo v·ªã tr√≠ X ƒë·ªÉ d·ªÖ ƒë·ªçc
    table.sort(formation, function(a, b)
        return a.position.x < b.position.x
    end)
    
    local jsonData = HttpService:JSONEncode(formation)
    writefile(formationFile, jsonData)
    
    print("‚úÖ ƒê√£ l∆∞u ƒë·ªôi h√¨nh v·ªõi " .. #formation .. " tower(s)")
    return formation
end

-- C·∫≠p nh·∫≠t th√¥ng tin tower trong file
local function UpdateTowerInFormation(hash, updateData)
    if not isfile(formationFile) then return end
    
    local success, formation = pcall(function()
        return HttpService:JSONDecode(readfile(formationFile))
    end)
    
    if not success then return end
    
    for i, towerData in ipairs(formation) do
        if towerData.hash == hash then
            -- C·∫≠p nh·∫≠t th√¥ng tin
            for key, value in pairs(updateData) do
                towerData[key] = value
            end
            
            -- L∆∞u l·∫°i file
            local jsonData = HttpService:JSONEncode(formation)
            writefile(formationFile, jsonData)
            print("üîÑ C·∫≠p nh·∫≠t tower:", towerData.name, "t·∫°i X =", towerData.position.x)
            return
        end
    end
end

-- X√≥a tower kh·ªèi file
local function RemoveTowerFromFormation(hash)
    if not isfile(formationFile) then return end
    
    local success, formation = pcall(function()
        return HttpService:JSONDecode(readfile(formationFile))
    end)
    
    if not success then return end
    
    for i = #formation, 1, -1 do
        if formation[i].hash == hash then
            local towerName = formation[i].name
            local towerX = formation[i].position.x
            table.remove(formation, i)
            
            -- L∆∞u l·∫°i file
            local jsonData = HttpService:JSONEncode(formation)
            writefile(formationFile, jsonData)
            print("üóëÔ∏è X√≥a tower:", towerName, "t·∫°i X =", towerX)
            return
        end
    end
end

-- T√¨m tower theo X
local function GetTowerByAxis(axisX)
    for hash, tower in pairs(TowerClass.GetTowers()) do
        local success, pos = pcall(function()
            local model = tower.Character:GetCharacterModel()
            local root = model and (model.PrimaryPart or model:FindFirstChild("HumanoidRootPart"))
            return root and root.Position
        end)
        if success and pos and math.abs(pos.X - axisX) <= 1 then
            local hp = tower.HealthHandler and tower.HealthHandler:GetHealth()
            if hp and hp > 0 then
                return hash, tower
            end
        end
    end
    return nil, nil
end

-- Ch·ªù ƒë·ªß ti·ªÅn
local function WaitForCash(amount)
    while cashStat.Value < amount do task.wait() end
end

-- ƒê·∫∑t tower
local function PlaceTowerRetry(name, pos, rotation)
    local placeCost = GetTowerPlaceCostByName(name)
    WaitForCash(placeCost)
    
    local args = {1, name, pos, rotation or 0}
    
    while true do
        Remotes.PlaceTower:InvokeServer(unpack(args))
        local t0 = tick()
        repeat
            task.wait(0.1)
            local hash = GetTowerByAxis(pos.X)
            if hash then 
                print("‚úÖ ƒê√£ ƒë·∫∑t:", name, "t·∫°i X =", pos.X)
                return hash
            end
        until tick() - t0 > 2
        warn("[RETRY] ƒê·∫∑t tower th·∫•t b·∫°i, th·ª≠ l·∫°i:", name, "X =", pos.X)
    end
end

-- N√¢ng c·∫•p tower
local function UpgradeTowerToLevel(axisX, targetLevels)
    local hash, tower = GetTowerByAxis(axisX)
    if not hash or not tower then return end
    
    for path = 1, 3 do
        local targetLevel = targetLevels[path] or 0
        if targetLevel > 0 then
            local currentLevel = tower.LevelHandler:GetLevelOnPath(path)
            
            for level = currentLevel + 1, targetLevel do
                local cost = tower.LevelHandler:GetLevelUpgradeCost(path, 1)
                if cost then
                    WaitForCash(cost)
                    Remotes.TowerUpgradeRequest:FireServer(hash, path, 1)
                    
                    -- Ch·ªù n√¢ng c·∫•p ho√†n th√†nh
                    local upgraded = false
                    local t0 = tick()
                    repeat
                        task.wait(0.1)
                        local _, t = GetTowerByAxis(axisX)
                        if t and t.LevelHandler then
                            local after = t.LevelHandler:GetLevelOnPath(path)
                            if after >= level then 
                                upgraded = true 
                                break 
                            end
                        end
                    until tick() - t0 > 3
                    
                    if not upgraded then
                        warn("‚ùå N√¢ng c·∫•p th·∫•t b·∫°i:", path, "level", level)
                        break
                    end
                end
            end
        end
    end
end

-- ƒê·ªïi target
local function ChangeTarget(axisX, targetType)
    local hash = GetTowerByAxis(axisX)
    if hash then
        Remotes.ChangeQueryType:FireServer(hash, targetType)
    end
end

-- Rebuild ƒë·ªôi h√¨nh
local function RebuildFormation()
    if not isfile(formationFile) then
        warn("‚ùå Kh√¥ng t√¨m th·∫•y file ƒë·ªôi h√¨nh!")
        return
    end
    
    local success, formation = pcall(function()
        return HttpService:JSONDecode(readfile(formationFile))
    end)
    
    if not success then
        warn("‚ùå L·ªói khi ƒë·ªçc file ƒë·ªôi h√¨nh!")
        return
    end
    
    print("üîÑ B·∫Øt ƒë·∫ßu rebuild ƒë·ªôi h√¨nh v·ªõi " .. #formation .. " tower(s)")
    
    -- ƒê·∫∑t towers
    for _, towerData in ipairs(formation) do
        local pos = Vector3.new(towerData.position.x, towerData.position.y, towerData.position.z)
        local hash = PlaceTowerRetry(towerData.name, pos, 0)
        
        if hash then
            -- C·∫≠p nh·∫≠t hash m·ªõi
            towerData.hash = hash
            
            -- N√¢ng c·∫•p
            if towerData.levels then
                UpgradeTowerToLevel(pos.X, towerData.levels)
            end
            
            -- ƒê·ªïi target
            if towerData.targetType and towerData.targetType ~= 1 then
                ChangeTarget(pos.X, towerData.targetType)
            end
        end
    end
    
    -- L∆∞u l·∫°i v·ªõi hash m·ªõi
    local jsonData = HttpService:JSONEncode(formation)
    writefile(formationFile, jsonData)
    
    print("‚úÖ Ho√†n th√†nh rebuild ƒë·ªôi h√¨nh!")
end

-- L·∫Øng nghe c√°c Remote events ƒë·ªÉ c·∫≠p nh·∫≠t file
Remotes.TowerFactoryQueueUpdated.OnClientEvent:Connect(function(data)
    local d = data[1]
    if not d then return end
    
    if d.Creation then
        -- Tower ƒë∆∞·ª£c ƒë·∫∑t - t·ª± ƒë·ªông l∆∞u v√†o formation
        task.wait(0.5) -- Ch·ªù tower ho√†n th√†nh
        SaveCurrentFormation()
    else
        -- Tower b·ªã b√°n - x√≥a kh·ªèi formation
        task.wait(0.1)
        SaveCurrentFormation() -- L∆∞u l·∫°i to√†n b·ªô ƒë·ªÉ ƒë·∫£m b·∫£o ƒë·ªìng b·ªô
    end
end)

Remotes.TowerUpgradeQueueUpdated.OnClientEvent:Connect(function(data)
    if data[1] then
        -- Tower ƒë∆∞·ª£c n√¢ng c·∫•p - c·∫≠p nh·∫≠t formation
        task.wait(0.5)
        SaveCurrentFormation()
    end
end)

Remotes.TowerQueryTypeIndexChanged.OnClientEvent:Connect(function(data)
    if data[1] then
        -- Target type thay ƒë·ªïi - c·∫≠p nh·∫≠t formation
        task.wait(0.1)
        SaveCurrentFormation()
    end
end)

-- Console commands
_G.rebuild = function()
    RebuildFormation()
end

_G.save = function()
    SaveCurrentFormation()
end

_G.clear = function()
    if isfile(formationFile) then
        delfile(formationFile)
        print("üóëÔ∏è ƒê√£ x√≥a file ƒë·ªôi h√¨nh")
    end
end

-- L∆∞u ƒë·ªôi h√¨nh ban ƒë·∫ßu
task.wait(2)
SaveCurrentFormation()

print("üéØ Formation Manager ƒë√£ kh·ªüi ƒë·ªông!")
print("üìã Commands:")
print("  ‚Ä¢ rebuild() - Rebuild ƒë·ªôi h√¨nh t·ª´ file")
print("  ‚Ä¢ save() - L∆∞u ƒë·ªôi h√¨nh hi·ªán t·∫°i")
print("  ‚Ä¢ clear() - X√≥a file ƒë·ªôi h√¨nh")
